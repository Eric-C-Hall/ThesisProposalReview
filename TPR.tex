\documentclass{article}

\title{Thesis Proposal Review}
\author{Eric Hall}

\begin{document}

\maketitle

\section{Thesis Proposal}

\subsection{Purpose of Thesis}

The thesis will be to produce a formally verified implementation of the Viterbi algorithm.



\subsection{What is the Viterbi algorithm}

The Viterbi algorithm is a 

\subsection{Starshot Resilient multi-mission space}

This project aligns closely with defence innovation network StarShot priority areas.

In particular, it would be useful in ``secure and resilient communications delivered from space for a highly networked force.''
%
%\subsection {Copy pasted from first research proposal}
%
%The purpose of this project is to use an interactive theorem prover to formally prove foundational mathematical theorems in the area of algebra, including such areas as group theory, field theory, and Galois theory. Future researchers will be able to build upon these proofs, improving our confidence that our mathematical theories are correct.
%
%Theorem proving has traditionally been done by hand, but this is time-consuming and prone to error. While humans are very good at understanding things on a conceptual level, they have a tendency to make silly mistakes when performing simple, boring, repetitive tasks, and the conceptual understanding they have of the topic has a tendency to obscure unjustified leaps in logic that appear “intuitive” to the human. Furthermore, the level of confidence that a third party has on the validity of a proof depends largely on how much they trust that the person performing the proof has done a good job at verifying their proof is correct. If they do not have such trust, then they must perform the boring, repetitive work of verifying the proof for themselves.
%
%The simple, boring and repetitive nature of checking the validity of a proof makes it a prime target for automation by computers, which excel at simple and repetitive tasks. By using a computer to perform the brute work of verifying the correctness of the proof, the user is able to prove theorems to an impeccably high standard of formality, without the arduous process of checking that each stage of the proof is formally correct. It also allows a third party to have a high level of trust in the validity of the proven theorem without having to check the proof themselves, so long as they trust that the proof-checking software has been programmed correctly.
%
%Furthermore, some theorem proving can be performed automatically by computers. This is best suited to simple and tedious derivations that need to be performed but do not require a high degree of understanding and are simply routine proofs. Using an automated theorem prover to make these derivations will take some of the load off the human prover, freeing the human from being bogged down in the minutiae of formal proof. Beyond that, the automated theorem provers may also have the ability to perform non-trivial proofs without the expenditure of human effort.
%
%Automated theorem provers have weaknesses, though. The place where humans really shine is in having a deep understanding of the meaning behind the theorems. Whereas the computer is just manipulating symbols, the human will typically have a better conceptual understanding of what these symbols mean and why they are important, and how they relate to each other. While work is ongoing in order to improve the ability of computers to attain this kind of understanding, this is still one of their weaknesses and humans will have an advantage in solving complex problems where a general understanding of the problem to be solved is useful.
%
%In this way, the human and computer solver cover each other’s weaknesses: the human excels at understanding the problem, whereas the automated theorem prover is very good at performing the grunt work.
%
%One major application area of interactive theorem proving is in proving the correctness of vital software in scenarios in which no bugs are tolerable. Examples of such application areas include cryptography, vote-counting software, medical software, software for controlling spacecraft or other vehicles, software for controlling industrial machinery such as nuclear power plants, etc. In such scenarios where any bug could have a catastrophic effect, it is important to be confident that your systems work as intended. By using an interactive theorem prover to prove that the output of the relevant code is correct, we may achieve the necessary confidence that our code is safe.
%
%Interactive theorem proving is also useful for improving our confidence in our understanding of mathematics and adjacent fields in general. Mathematics underpins much of the modern world, and to be confident in the effectiveness of many real-world systems, it is important to be confident in the underlying mathematics. The process of formalizing our mathematical theories is likely to expose flaws in our current understanding of mathematics, especially in the less well-trodden areas where the proofs have not been exposed to the level of scrutiny that is typical of more widely studied areas of mathematics.
%
%My specific project aims to be a foundational building block in achieving these goals. I aim to produce a computer-assisted formalization of commonly used mathematical theorems, so that future researchers can build on top of this to produce computer-formalized proofs of theorems that are important in their own application areas. This could be used by future researchers both in domain-specific applications and in simply solidifying our understanding of mathematics in general. 
%
%The specific area I would like to work in is algebra: in particular, areas such as group theory, field theory, and Galois theory. These are fundamental areas of study of vital importance to a large number of other disciplines, which is why I chose them as a topic of study.
%
%As of right now, I am still in the beginning stages of literature review to identify pre-existing research on the topic. There does seem to be at least some relevant literature already on the topic of the formalization of Galois theory (see [1] and [2]). Although research has been done in this area before, there is still likely room to perform more research, as there are many useful theorems and only some will have been formalized. In addition, I expect that there are many closely related fields of algebra which have not yet had formalization work applied to them.
%
%Novel ideas will be required in order to formalize the mathematics, because the theorems have not been proven to the required standard of rigor necessary. The existing proofs will likely be in a human-readable form rather than in a formal, computer-readable form, and as a result they will likely be missing key details necessary to make the proofs work in an interactive theorem prover setting.
%
%References:
%
%[1]    T. Browning and P. Lutz. “Formalizing Galois Theory”. Experimental Mathematics, vol. 31, pp 413-424, 2021
%
%[2]    N. Curiel. “Formalizing Galois Theory I: Automorphism Groups of Fields”. Master’s Thesis, California State University San Marcos, MSc, 2011
%
%[3]    M. Norrish. “Mechanised Computability Theory”. International Conference on Interactive Theorem Proving, pp 297-311, 2011
%
%[4]    R. Affeldt, J. Garrigue and T. Saikawa. “Formalization of Reed-Solomon codes and progress report on formalization of LDPC codes”. International Symposium on Information Theory and Its Applications, pp 532-536, 2016
%
%https://ieeexplore.ieee.org/document/7840481 Formalization of Reed-Solomon codes and progress report on formalization of LDPC codes
%
%\subsection{Copy pasted from second research proposal}
%
%The purpose of this project is to use an interactive theorem prover to produce a formally verified implementation of the Viterbi algorithm. This would also involve the formalization of underlying mathematical theorems which could be of general use.
%
%When reading data from a noisy channel, errors are likely to occur. If we provide redundant information over this channel, then when an error occurs, it is possible to use the redundant information to correct the error with high probability [1]. Encodings of data that allow for this error-correcting property are called error-correcting codes.
%
%The Viterbi algorithm is an algorithm that is used to decode a certain class of error-correcting codes [2].
%
%Interactive theorem proving is a technique used to formally prove that a system works correctly with respect to a specification [3]. As long as there is trust that the theorem prover and the specification are both correct, this provides an 100% guarantee that the algorithm behaves correctly. This is useful in situations where failure could be catastrophic and thus we need extremely reliable software, for example in pacemakers or self-driving cars.
%
%It would be useful to have a formally verified implementation of the Viterbi algorithm, because the algorithm may be used in systems that have a requirement of high reliability. It is extremely common to need to read information from a potentially noisy channel. Common examples include reading from a wireless connection [4] or even from a hard drive [5]. Most real-world systems would have a need to do these kinds of basic tasks, thus, most real-world systems have a need for error-correcting codes to some degree. This includes those systems that would benefit from the correctness guarantees provided by formal proof. Thus, the improved reliability of having a formally verified implementation of the Viterbi algorithm would be useful in practice in real-world systems with low fault tolerance.
%
%Formalization of other error correcting codes has been performed in the past. For example, the correctness of Reed-Solomon codes has been formally proved using interactive theorem provers [6]. Also, the correctness of the Viterbi algorithm has been proven using handwritten methods [2], although handwritten methods are by nature less reliable than computer-verified methods. However, in my preliminary review of the literature, I have not encountered a computer verified formalization of the Viterbi algorithm. Thus, it should satisfy the novelty requirements of a PhD. 
%
%The formal proving process is not merely a mechanical implementation process. Previous proofs of the correctness of the Viterbi algorithm were written to satisfy a human reviewer, not to satisfy a formal computer verifier. Therefore, they almost certainly handwave parts of the proof, and have gaps in them which they fail to prove to a sufficient standard of rigor. In order to fill in the gaps in the proof, it will be necessary to come up with new ideas, rather than merely implementing old ones. Thus, the project also has the element of research that is expected of a PhD (rather than being pure development work).
%
%The formalization will require a significant amount of work, because proving something to the requisite standard of rigor necessary for formal proof requires it to be proven to a high level of detail. Furthermore, there is ample room for extending the project in case it takes less work than expected. In 2016, R Affeldt et al said that formal verification of error-correcting codes is understudied [6], and based on my preliminary review of the literature, I agree that there is a significant amount of room for expansion. Thus, even in the case where the production of a formally verified Viterbi algorithm takes less work than expected, it should be possible to extend the project by performing more work, for example, by proving the correctness of other error correcting code algorithms. Therefore, it should be possible to perform sufficient work in this area to be appropriate for a PhD.
%
%On the other hand, the amount of work required can be realistically achieved within a PhD project. Interactive theorem provers are a proven technology that have been used to produce formally verified implementations of several algorithms, for example a formally verified OS kernel [7] and a formally verified compiler of a pure programming language [8]. This shows that the techniques necessary to produce a formally verified implementation of even complex algorithms is available. On the one hand, the formal implementations of these algorithms involved several authors, but on the other hand they also were implementations of relatively complicated systems, so in my estimation the amount of work required to produce a formally verified implementation of the Viterbi algorithm should be appropriate for a PhD.
%
%To evaluate my progress mid-way through the PhD, it should be possible to look at the proofs and specifications that have been produced so far. The project will have several stages which will need to be completed before the project as a whole can be completed. For example, we will need to create a specification for the Viterbi algorithm, we will need to prove theorems describing the mathematical background that the Viterbi algorithm is based upon, and we will need to prove the correctness of individual parts of the Viterbi algorithm. Then in order to evaluate how much progress I have made in my PhD, I should be able to look at how many proofs/specifications have been written so far. This would allow us to have a sense of whether or not progress was being made on the project, providing a greater guarantee that the PhD program would be completed successfully and on time.
%
%In summary, my proposal is to use an interactive theorem prover to produce a formally verified implementation of the Viterbi algorithm. This would be useful because error-correcting codes are necessary in a wide variety of applications, including those in which it is necessary to have a high level of confidence in the correctness of the software. This project would be feasible, as similar projects have been completed before, and this project would take a significant amount of work, as a high level of detail would be necessary to provide a sufficiently rigorous formal proof. It would furthermore be possible to evaluate the progression of the project by evaluating the work that has been completed so far, which could include a specification for the Viterbi algorithm or the proof of sub-theorems necessary in the correctness proof of the overall algorithm.
%
%References:
%
%[1]    J. Baylis, Error Correcting Codes: A Mathematical Introduction. Boca Raton: Chapman \& Hall, 1998.
%
%[2]    A. Viterbi, “Error Bounds for Convolutional Codes and an Asymptotically Optimum Decoding Algorithm,” IEEE Transactions on Information Theory, vol. 13, pp. 260-269, Apr 1967.
%
%[3]    Y. Bertot, P. Casteran, Interactive Theorem Proving and Program Development: Coq’Art: The Calculus of Inductive Constructions. Heidelberg: Springer-Verlag, 2004.
%
%[4]    M. C. Vuran, I. F. Akyildiz, “Error Control in Wireless Sensor Networks: A Cross Layer Analysis”, IEEE/ACM Transactions on Networking, vol. 17, pp. 1186-1199, Aug 2009
%
%[5]    D. Patterson, G. Gibson, R. H. Katz, “A Case for Redundant Arrays of Inexpensive Disks (RAID),” Proceedings of the 1988 ACM SIGMOD International Conference on Management of Data, pp. 109-116, Jun 1988
%
%[6]    R. Affeldt, J. Garrigue and T. Saikawa, “Formalization of Reed-Solomon codes and progress report on formalization of LDPC codes,” International Symposium on Information Theory and Its Applications, pp. 532-536, Oct 2016.
%
%[7]    G. Klein, K. Elphinstone, G. Heiser, J. Andronivk, D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch, S. Winwood, “seL4: Formal Verification of an OS Kernel,” Proceedings of the ACM SIGOPS 22nd symposium on Operating systems principles, pp. 207-220, Oct 2009.
%
%[8]    R. Kumar, M. O. Myreen, M. Norrish, S. Owens, “CakeML: a verified implementation of ML,” ACM Sigplan Notices, vol. 49, pp. 179-191, Jan 2014.
%
\section{Literature Review}

\subsection{Viterbi related}

\subsubsection{Wikipedia}

The Viterbi algorithm is an algorithm which allows you to determine the most likely sequence of states in a hidden Markov model that lead to a certain sequence of observations.

Note that this sequence of states may not necessarily have a high probability, but it is the most likely sequence of states out of all possible sequences of states.

This algorithm is used in decoding convolutional codes. For example, (direct quote here):  ``CDMA and GSM digital cellular, dial-up modems, satellite, deep-space communications, and 802.11 wireless LANs.''

(direct quote) ``It is now also commonly used in speech recognition, speech synthesis, diarization,[1] keyword spotting, computational linguistics, and bioinformatics''

It is a dynamic programming algorithm.

Let $P_{s,t}$ denote the probability of the maximum probability path ending in the state $s$ at the time $t$.

At $t = 0$, we know that $P_{s,t}$ is equal to the prior probability of being in that state multiplied by the probability of seeing the first observation if you are in that state.

At each time beyond that, $P_{s,t}$ is equal to the maximum over all states $s'$ of $P_{s', t-1}$ multiplied by the transition probability between $s'$ and $s$, multiplied by the probability of seeing the observation that was observed at time $t$ if we are in state $s$.

Also make sure to keep track of the transitions that were used to obtain each maximum probability path.

Thus we can use dynamic programming techniques to first calculate all the probabilities at time 0, then calculate all the probabilities at time 1, then calculate all the probabilities at time 2, etc. This will avoid having to re-calculate the probabilities at time 0 multiple times when, for example, finding the maximum probability paths to several different states at a time far in the future. In particular, this will not need to be calculated once for every possible path it is possible to take, but rather, it will only need to be calculated once.

\subsubsection{(high importance) Viterbi's original paper: Error bounds for convolutional codes and an asymptotically optimum decoding algorithm }

\subsubsection{Viterbi algorithm for error correction}

\subsubsection{(unknown quality, google search) The Viterbi Algorithm, by G David Forney, JR}

% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Formal ECC Verification}

\subsubsection{(unkown quality, google search) Pragmatic Formal Verification of Sequential Error
Detection and Correction Codes (ECCs) used in
Safety-Critical Design (Aman Kumar)}

(Seems relevant, more review necessary)

Formal verification

Mentions Hamming codes, Hsaio codes, Reed-Solomon codes and Bose-Chandhuri-Hocquenghem codes

(direct quote) ``The ECC used in this work is a combinatorial Quad Bit Error Detection, Triple Bit Error Correction (QEDTEC) ECC''.

\subsubsection{Formal Verification by The Book: Error Detection and Correction Codes}

% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Error-Correcting codes theory}

\subsubsection{(found via google search) A course in error-correcting codes, by J Justesen, T Høholdt }

Pretty standard, not much unique

\subsection{(cited by Aman Kumar, book) Error Detection and Correction Codes by Diego L. Gonzalez}

Moderate relevance. Information on ECCs



% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Soft errors (what are these? Probably unrelated)}

\subsubsection{(cited by Aman Kumar, book) Soft errors in Modern Electronic Systems}

\subsubsection{(cited by Aman Kumar, book) Dependability in electronic systems - Mitigation of Hardware Failures, Soft Errors, and Electro-Magnetic Disturbances}

Probably only tangentially relevant

\subsection{Other formal verification}

\subsubsection{(cited by Aman Kumar) Formal Verification, An Essential Toolkit for Modern VLSI Design} 

Low relevance

\subsection{Low relevance}

\subsubsection{(cited by Aman Kumar) Error correcting code analysis for cache memory high reliability and performance}

Low relevance


\subsection{(cited by Aman Kumar) Formal verification by the book: Error detection and correction codes}
Signals and Communication Technology
Martin Tomlinson
Cen Jung Tjhai
Marcel A. Ambroze
Mohammed Ahmed
Mubarak Jibril
Moderate/High relevance

\subsection{Formalization of Error-correcting Codes: from Hamming to Modern Coding Theory}

Linear ECCs?

\subsection {(from google) Error-Correction Coding and Decoding by Martin Tomlinson, Cen Jung Tjhai, Marcel A. Ambroze, Mohammed Ahmed, Mubarak Jibril}

Lots of interesting codes, e.g. algebraic geometry codes

\subsection {Joe Hurd PhD thesis Formal verification of probabilistic
algorithms (recommended by Michael)}

The thesis is aqbout how to fomally verify probabilitic algorithms. Not specific to HOL4, although HOL4 is the theorem prover that was used.

\begin{itemize}
\item {Formally verified probabilistic algorithms example}
\item {Probability foundations}
\item {Probabilstic program modelling}
\item {Verify Miller-Rabin test}
\item {}
\item {}
\item {}
\item {}
\end{itemize}


\subsection{Formalizing Integration Theory, with an
Application to Probabilistic Algorithms
Stefan Richter 
(unkown quality, found via google because it cites Joe Hurd's thesis)}

Conclusion: unlikely to be relevant. In Isabelle. On the other hand, is an approach for formalization of Probability-relevant background.

\begin{itemize}
\item {Uses Isabelle}
\item {Lesbegue integration}
\item {Sigma algebra}
\item {Monotone convergence}
\item {Measure spaces}
\item {Real-valued random variables}
\item {Integration}
\item{Probability spaces}
\end{itemize}

\section{Formalization of Reed-Solomon codes and progress report on formalization of LDPC codes}

\section{Research activities since commencement}

\subsection {Fermat's Little Theorem}

\subsection {Simple block codes proof}

\subsubsection {Block codes theory}

\subsubsection{}	


\subsection {Extreal to real, polynomial solver.}


\section{Methodology to be Employed}

The HOL4 interactive theorem prover will be used to prove theorems.

\section{How my research will contribute to my field of study}

\section{Bibliography}


\end{document}